# 背包 dp
背包dp时一类特殊的dp，主要的特点在于元素只有两种状态，要么是选，要么是不选。

### 1. 0-1 背包问题
每种物品只能选择放入或不放入背包中一次。状态转移方程为：
```python
for i in range(1, n+1):  # 遍历物品
    for j in range(V, w[i]-1, -1):  # 遍历背包容量
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```
其中 `dp[j]` 表示容量为 `j` 的背包所能达到的最大价值，`w[i]` 和 `v[i]` 分别是第 `i` 个物品的重量和价值。

### 2. 完全背包问题
每种物品可以无限次放入背包中。状态转移方程为：
```python
for i in range(1, n+1):
    for j in range(w[i], V+1):
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

### 3. 多重背包问题
每种物品可以放入有限次数。状态转移方程可以通过二进制优化或单调队列优化来实现。

### 4. 混合背包问题
背包中的物品可能是0-1背包、完全背包或多重背包中的一种。解决方法是结合以上三种背包的处理方式。

### 5. 二维费用背包问题
每种物品的消耗有两种资源（如体积和重量）。状态转移方程为：
```python
for i in range(1, n+1):
    for j in range(V, v[i]-1, -1):
        for k in range(W, w[i]-1, -1):
            dp[j][k] = max(dp[j][k], dp[j-v[i]][k-w[i]] + c[i])
```
其中 `dp[j][k]` 表示容量为 `j` 和重量为 `k` 的背包所能达到的最大价值。

### 6. 分组背包问题
物品分为若干组，每组中最多选择一个物品。状态转移方程为：
```python
for k in range(1, ts+1):  # 遍历每一组
    for i in range(m, 0, -1):  # 遍历背包容量
        for j in range(1, cnt[k]+1):  # 遍历该组的每一个物品
            if i >= w[t[k][j]]:  # 背包容量充足
                dp[i] = max(dp[i], dp[i-w[t[k][j]]] + c[t[k][j]])
```

### 7. 有依赖的背包问题
某些物品的选择依赖于其他物品的选择。通常需要先处理依赖物品。

### 8. 其他优化技巧
包括单调队列优化、斜率优化等，用于处理特定类型的背包问题，以提高效率。

这些是背包问题的基本类型和解决策略。每种类型的背包问题都有其特定的状态转移方程和优化方法，适当选择和应用这些方法可以有效解决问题。